<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>利用本地浏览器在远程服务器上进行访问</title>
    <link href="/2023/12/22/%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/"/>
    <url>/2023/12/22/%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在很多情况下可能都会出现这样的场景：我们想要基于一个远程server的ip来对某些网页进行访问，但是服务器通常是没有GUI端的 Linux 系统：</p><ul><li>服务器需要特殊的网关登录才能够上网，需要在指定的内网 IP 下才能访问网关</li><li>服务器部署在内网内，需要从内网访问某些资源</li><li>在虚拟机&#x2F;容器内部署了一套集群，组件（例如 Hadoop，Spark）的 WebUI 和监控需要从指定的端口进行访问，然而端口太多，全部映射出来不方便</li></ul><p>虽然可以在服务器安装 GUI 后在利用 remote desktop 进行访问，但是这样其实也是比较麻烦的，同时一些GUI可能在云服务器上的安装是不被允许的</p><p>所以我们想要找到一个方法，能够在本地浏览器上，基于远程服务器的 IP，进行网页访问</p><p>一个比较快捷的方法是配置 socks5 代理</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>首先需要用 ssh 配置一个端口转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh —D[Port] username@host <br><span class="hljs-comment"># 如果server的登录需要指定端口</span><br>ssh -D[port] username@host -p [LoginPort]<br></code></pre></td></tr></table></figure><p>然后再在浏览器中配置 socks5 代理</p><p><img src="/2023/12/22/%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%A8%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE/proxy.png" alt="proxy"></p><p>代理协议选择 SOCKS5，代理服务器选择 localhost，端口选择之前端口转发配置的 <code>[Port]</code>，在这里我们用了20000</p><p>在配置好这个代理之后就可以使用这个代理在远程服务器上进行上网</p><div class="note note-info">            <p>Chrome 浏览器目前无法直接配置 SOCKS5 代理，需要下载插件 <a href="https://chromewebstore.google.com/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif">Proxy SwitchOmege</a><br>Firefox 可以直接配置</p>          </div>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VS Code + Python 开发 QGIS 插件环境配置指南</title>
    <link href="/2023/10/22/VS-Code-Python-%E5%BC%80%E5%8F%91-QGIS-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2023/10/22/VS-Code-Python-%E5%BC%80%E5%8F%91-QGIS-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><div class="note note-info">            <p>整篇教程 For Windows，好像Mac没有这么多事。前一段开发插件的时候给同组的同学写的配置文档，恰好发现中文互联网上相关的内容比较少，也不太系统，做一个系统的整理。</p>          </div><h1 id="QGIS-官方Plugin-文档"><a href="#QGIS-官方Plugin-文档" class="headerlink" title="QGIS 官方Plugin 文档"></a>QGIS 官方Plugin 文档</h1><h2 id="Official-Version-What’s-Next-For-Dialog-Plugins"><a href="#Official-Version-What’s-Next-For-Dialog-Plugins" class="headerlink" title="Official Version (What’s Next For Dialog Plugins)"></a>Official Version (What’s Next For Dialog Plugins)</h2><ol><li>If resources.py is not present in your plugin directory, compile the resources file using pyrcc5 (simply use <code>pb_tool</code> or <code>make</code> if you have automake)</li><li>Optionally, test the generated sources using <code>make test</code> (or run tests from your IDE)</li><li>Copy the entire directory containing your new plugin to the QGIS plugin directory (see Notes below)</li><li>Test the plugin by enabling it in the QGIS plugin manager</li><li>Customize it by editing the implementation file <code>viewshed_analysis.py</code></li><li>Create your own custom icon, replacing the default <code>icon.png</code><br>Modify your user interface by opening <code>viewshed_analysis_dialog_base.ui</code> in Qt Designer</li></ol><h1 id="QGIS-插件开发的环境配置"><a href="#QGIS-插件开发的环境配置" class="headerlink" title="QGIS 插件开发的环境配置"></a>QGIS 插件开发的环境配置</h1><h2 id="Environment-Configuration"><a href="#Environment-Configuration" class="headerlink" title="Environment Configuration"></a>Environment Configuration</h2><p>最基础的版本：<a href="https://zhuanlan.zhihu.com/p/344965380">知乎网站：从0开始开发QGIS插件</a></p><p>用于自动创建 GUI 界面的 QGIS 插件：<a href="https://www.qgistutorials.com/en/docs/3/processing_python_plugin.html">Building a Processing Plugin</a> (<a href="https://www.osgeo.cn/qgis-tutorial/docs/3/processing_python_plugin.html">In Chinese</a>)</p><blockquote><p>上面这个工具插件有效解决了插件GUI的问题，可以直接用与QGIS风格非常统一的GUI进行开发，这个工具只适用于算法处理相关的插件</p></blockquote><h2 id="如何把-Tool-导入-QGIS-中"><a href="#如何把-Tool-导入-QGIS-中" class="headerlink" title="如何把 Tool 导入 QGIS 中"></a>如何把 Tool 导入 QGIS 中</h2><ol><li><p>在 Debug 之前首先我们需要将开发好的插件加入到 QGIS 的环境中，这里提供两种方式：</p><ol><li><p>直接把用 Plugin Builder 生成好的整个插件目录拷到<code>C:\Users\---\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins</code></p></li><li><p>这里更推荐用 symbolic link 的方法直接创建软链接 </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mklink /D <span class="hljs-string">&quot;C:\Users\---\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins\your_plugin&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$</span>&#123;your_plugin_workspace&#125;\your_plugin&quot;</span><br></code></pre></td></tr></table></figure></li></ol> <div class="note note-warning">            <p>WARNING: There is a huge risk though of losing your code if you uninstall the plugin by accident.</p>          </div></li><li><p>重启 QGIS, Menu Plugins -&gt; Manage and Install Plugins</p></li><li><p>把 viewshed analysis 打钩</p></li><li><p>在 Plugins 菜单或者 Toolbox 中可以找到对应的插件</p></li></ol><h1 id="关于使用-VS-Code-进行开发的问题"><a href="#关于使用-VS-Code-进行开发的问题" class="headerlink" title="关于使用 VS Code 进行开发的问题"></a>关于使用 VS Code 进行开发的问题</h1><div class="note note-warning">            <p>用 VS Code 开发是一件非常 tricky 的事情，这可能需要非常长的配置时间</p>          </div><p><strong>再次声明，好像只有Windows有这么多麻烦的问题</strong></p><p>另外，根据官方网站的推荐，最好使用 long-term-release 的版本进行开发 非 long-term-release 的版本的路径可能与下文中的描述略有区别，主要是各种路径和文件名中 qgis-ltr 和 qgis 的区别</p><h2 id="如何在-Integrated-terminal-运行"><a href="#如何在-Integrated-terminal-运行" class="headerlink" title="如何在 Integrated terminal 运行"></a>如何在 Integrated terminal 运行</h2><p>有几种方案解决import qgis相关的问题：</p><ul><li><p>根据以下文件自己配置 settings.json，这些文件基本可以在 QGIS 的根目录下找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">%OSGEO4W_ROOT%/bin/python-qgis-ltr.bat    <br>%OSGEO4W_ROOT%/bin/o4w_env.bat    <br>%OSGEO4W_ROOT%/bin/o4w_env.bat<br></code></pre></td></tr></table></figure></li><li><p>在 Integrated terminal 中运行 <code>%OSGEO4W_ROOT%/bin/python-qgis-ltr-env.bat </code>后再运行python程序</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">rem python<span class="hljs-literal">-qgis-ltr-env</span>.bat    <br>@<span class="hljs-built_in">echo</span> off    call <span class="hljs-string">&quot;%~dp0\o4w_env.bat&quot;</span>   <br>@<span class="hljs-built_in">echo</span> off    path %OSGEO4W_ROOT%\apps\qgis<span class="hljs-literal">-ltr</span>\bin;%PATH%    <br><span class="hljs-built_in">set</span> QGIS_PREFIX_PATH=%OSGEO4W_ROOT:\=/%/apps/qgis<span class="hljs-literal">-ltr</span>   <br><span class="hljs-built_in">set</span> GDAL_FILENAME_IS_UTF8=YES    <br>rem <span class="hljs-built_in">Set</span> VSI cache to be used as buffer, see <span class="hljs-comment">#6448    </span><br><span class="hljs-built_in">set</span> VSI_CACHE=TRUE    <br><span class="hljs-built_in">set</span> VSI_CACHE_SIZE=<span class="hljs-number">1000000</span>    <br><span class="hljs-built_in">set</span> QT_PLUGIN_PATH=%OSGEO4W_ROOT%\apps\qgis<span class="hljs-literal">-ltr</span>\qtplugins;%OSGEO4W_ROOT%\apps\qt5\plugins    <br><span class="hljs-built_in">set</span> PYTHONPATH=%OSGEO4W_ROOT%\apps\qgis<span class="hljs-literal">-ltr</span>\python;%PYTHONPATH%<br></code></pre></td></tr></table></figure></li><li><p>Thanks to <a href="https://gist.github.com/thbaumann/73c873d4c49d8c1add8dc97359cebabe%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%B0%86.bat%E4%BD%9C%E4%B8%BA">https://gist.github.com/thbaumann/73c873d4c49d8c1add8dc97359cebabe，有一个更简单的方法可以直接将.bat作为</a> vscode 的解释器 (在 vscode 的设置中无法将非.exe的文件设为解释器)</p><blockquote><p>The bread and butter of this configuration is “python.pythonPath”: “C:&#x2F;OSGeo4W64&#x2F;bin&#x2F;python-qgis.bat”, which sets all the correct paths and bindings for us. I don’t really know why it works to refer a .bat file as python interpreter, but apparently it’s fine and fixes alot of linting issues.</p></blockquote></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// settings.json    </span><br><span class="hljs-punctuation">&#123;</span> <br>        <span class="hljs-comment">// 第一个选项貌似是过时的</span><br>        <span class="hljs-attr">&quot;python.pythonPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot; %OSGEO4W_ROOT%\\bin\\python-qgis-ltr.bat&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;python.defaultInterpreterPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;%OSGEO4W_ROOT%\\bin\\python-qgis-ltr.bat&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>还有一个 tricky 的点是相对路径引用的问题：</p><div class="note note-info">            <p>这段东西是针对 dialog 的那种自己写 GUI 的 plugin 的，processing 系列的插件不太受到这个困扰</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This works for integragted terminal</span><br><span class="hljs-comment"># Initialize Qt resources from file resources.py</span><br><span class="hljs-keyword">from</span> resources <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Import the code for the dialog</span><br><span class="hljs-keyword">from</span> visibility_analysis_dialog <span class="hljs-keyword">import</span> VisibilityAnalysisDialog<br><span class="hljs-comment"># --------------------------------------</span><br><span class="hljs-comment"># This works for qgis </span><br><span class="hljs-comment"># Initialize Qt resources from file resources.py</span><br><span class="hljs-keyword">from</span> .resources <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># Import the code for the dialog</span><br><span class="hljs-keyword">from</span> .visibility_analysis_dialog <span class="hljs-keyword">import</span> VisibilityAnalysisDialog<br></code></pre></td></tr></table></figure><h2 id="Debugging-in-VS-Code"><a href="#Debugging-in-VS-Code" class="headerlink" title="Debugging in VS Code"></a>Debugging in VS Code</h2><blockquote><p>Thanks to<br><a href="https://gispofinland.medium.com/cooking-with-gispo-qgis-plugin-development-in-vs-code-19f95efb1977">https://gispofinland.medium.com/cooking-with-gispo-qgis-plugin-development-in-vs-code-19f95efb1977</a><br><a href="https://gist.github.com/thbaumann/73c873d4c49d8c1add8dc97359cebabe">https://gist.github.com/thbaumann/73c873d4c49d8c1add8dc97359cebabe</a></p></blockquote><p>利用 VS Code 对 QGIS 插件进行开发需要利用 QGIS 中的 Debugvs 插件，这个插件会在本地的 5678 端口创建一个 debug 的传输通道，让 VS Code 的 debug launch 可以进行远程的 attach debugging。</p><p>在安装这个插件之前，我们需要在 <strong>QGIS 对应的 python 目录下</strong>安装 ptvsd</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip install ptvsd<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>这里建议一定在安装之前检查一下当前 Python 的版本是否正确，建议直接打开 OSGeo4W shell 进行配置（通常在<code>%OSGeo4w_ROOT\OSGeo4W.bat</code>）<br>之后直接在 QGIS 中安装 Debugvs 即可</p>          </div><p>我们还需要额外配置一下 VS Code 的 <code>launch.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Python: Remote Attach&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;python&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;attach&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5678</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pathMappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;localRoot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/your_plugin&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// path to your plugin where you are developing</span><br>            <span class="hljs-attr">&quot;remoteRoot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C:\\Users\\---\\AppData\\Roaming\\QGIS\\QGIS3\\profiles\\default\\python\\plugins\\your_plugin&quot;</span> <span class="hljs-comment">// path to where the QGIS plugin folder lives </span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>安装好之后在 QGIS 中点击 <code>Plugins -&gt; Enable Debug for Visual Studio -&gt; Enable Debug for Visual Studio</code> 即可打开 Debug Port (localhost:5678)，随后在 VS Code 中直接运行 Debug 即可</p><p>每一次修改之后都要用 <code>Plugin Reloader</code> reload 一次</p>]]></content>
    
    
    <categories>
      
      <category>GIS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VS Code</tag>
      
      <tag>Python</tag>
      
      <tag>QGIS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 建站总结</title>
    <link href="/2023/10/22/hexo-%E5%BB%BA%E7%AB%99/"/>
    <url>/2023/10/22/hexo-%E5%BB%BA%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-建站过程"><a href="#Hexo-建站过程" class="headerlink" title="Hexo 建站过程"></a>Hexo 建站过程</h1><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><ol><li><p>一个 Github 账号，<a href="https://blog.csdn.net/yaorongke/article/details/119086305">申请教程</a></p></li><li><p>在电脑上安装 git，[git安装教程]在(<a href="https://blog.csdn.net/yaorongke/article/details/119085413">https://blog.csdn.net/yaorongke/article/details/119085413</a>)</p></li><li><p>在电脑上安装 NodeJS，<a href="https://blog.csdn.net/yaorongke/article/details/119084295">NodeJS安装教程</a></p></li></ol><h2 id="Hexo-安装和本地测试"><a href="#Hexo-安装和本地测试" class="headerlink" title="Hexo 安装和本地测试"></a>Hexo 安装和本地测试</h2><ol><li><p>安装 hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>查看 hexo 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure></li><li><p>创建 blog</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">hexo init </span><span class="hljs-template-variable">&#123;YOUR_BLOG_NAME&#125;</span><span class="language-xml"></span><br><span class="language-xml">cd </span><span class="hljs-template-variable">&#123;YOUR_BLOG_NAME&#125;</span><span class="language-xml"></span><br><span class="language-xml">npm install</span><br></code></pre></td></tr></table></figure></li><li><p>blog的本地启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d <span class="hljs-comment"># generate and deploy</span><br>hexo s <span class="hljs-comment"># server</span><br></code></pre></td></tr></table></figure></li><li><p>浏览器访问 <code>http://localhost:4000</code> 即可打开新建的博客，页面的默认风格如下<br><img src="/2023/10/22/hexo-%E5%BB%BA%E7%AB%99/hexo_default.png" alt="hexo默认页面"></p></li></ol><p>Hexo 的默认主题可能比较丑陋，不过hexo本身提供了很多不同的主题，比较常用（互联网上资源较多的）有 <a href="https://theme-next.js.org/">NeXT</a> 和 <a href="https://hexo.fluid-dev.com/">Fluid</a></p><h2 id="Github-pages部署"><a href="#Github-pages部署" class="headerlink" title="Github pages部署"></a>Github pages部署</h2><h1 id="Hexo-官方-Hello-world"><a href="#Hexo-官方-Hello-world" class="headerlink" title="Hexo 官方 Hello world"></a>Hexo 官方 Hello world</h1><div class="note note-info">            <p>这个官方的 Hello world 可以看做是一个操作手册</p>          </div><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客建站</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客美化自述</title>
    <link href="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/"/>
    <url>/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这里主要记录一下本博客建站过程中用到的美化手段共参考考</p></blockquote><h1 id="访问量统计"><a href="#访问量统计" class="headerlink" title="访问量统计"></a>访问量统计</h1><p><code>Fluid</code> 主题中针对阅读量已经有写好的代码，但是需要自己配置第三方的数据量统计服务才能使用。我们这里使用 <code>LeanCloud</code> 的免费服务来进行统计，同时这个也可以直接用来接入后面的评论区</p><h2 id="1-申请-LeanCloud-账号并创建应用"><a href="#1-申请-LeanCloud-账号并创建应用" class="headerlink" title="1. 申请 LeanCloud 账号并创建应用"></a>1. 申请 LeanCloud 账号并创建应用</h2><p>进入<a href="https://console.leancloud.cn/">官网</a> 注册账号</p><p><img src="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/%E6%B3%A8%E5%86%8C.png" alt="注册页面"></p><p>注册后需要实名认证和邮箱验证，完成后才能使用各项服务</p><p>验证完成后选择创建应用，选择免费的开发版即可</p><p><img src="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="创建应用"></p><p>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code>, <code>AppKey</code>, <code>REST API 服务器地址</code> 三个属性，记录下来后面使用</p><p><img src="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95.png" alt="应用记录"></p><h2 id="2-修改-Fluid-配置"><a href="#2-修改-Fluid-配置" class="headerlink" title="2 修改 Fluid 配置"></a>2 修改 Fluid 配置</h2><p>在 <code>_config.fluid.yml</code> 中或者 fluid 主题的 <code>_config.yml</code> 中修改找到以下配置项，按照下文内容修改配置</p><h3 id="网页访问统计配置"><a href="#网页访问统计配置" class="headerlink" title="网页访问统计配置"></a>网页访问统计配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">web_analytics:</span>  <span class="hljs-comment"># 网页访问统计</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span><br>  <span class="hljs-comment"># LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase</span><br>  <span class="hljs-attr">leancloud:</span><br>    <span class="hljs-attr">app_id:</span> <span class="hljs-string">你的</span> <span class="hljs-string">AppId</span><br>    <span class="hljs-attr">app_key:</span> <span class="hljs-string">你的</span> <span class="hljs-string">AppKey</span><br>    <span class="hljs-comment"># REST API 服务器地址，国际版不填</span><br>    <span class="hljs-comment"># Only the Chinese mainland users need to set</span><br>    <span class="hljs-attr">server_url:</span> <span class="hljs-string">你的</span> <span class="hljs-string">REST</span> <span class="hljs-string">API</span> <span class="hljs-string">服务器地址</span><br>    <span class="hljs-comment"># 统计页面时获取路径的属性</span><br>    <span class="hljs-comment"># Get the attribute of the page path during statistics</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>    <span class="hljs-comment"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span><br>    <span class="hljs-comment"># If true, ignore localhost &amp; 127.0.0.1</span><br>    <span class="hljs-attr">ignore_local:</span> <span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h3 id="打开文章的浏览量计数功能"><a href="#打开文章的浏览量计数功能" class="headerlink" title="打开文章的浏览量计数功能"></a>打开文章的浏览量计数功能</h3><p>这个在 <code>_config.fluid.yml</code> 的 post 配置下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>    <span class="hljs-comment"># 浏览量计数</span><br>    <span class="hljs-comment"># Number of visits</span><br>    <span class="hljs-attr">views:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 统计数据来源</span><br>      <span class="hljs-comment"># Data Source</span><br>      <span class="hljs-comment"># Options: busuanzi | leancloud</span><br>      <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span><br>      <span class="hljs-attr">format:</span> <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br></code></pre></td></tr></table></figure><h3 id="页面底部展示网站的-PV，UV"><a href="#页面底部展示网站的-PV，UV" class="headerlink" title="页面底部展示网站的 PV，UV"></a>页面底部展示网站的 PV，UV</h3><p>在 <code>footer</code> 配置项中做调整</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># 展示网站的 PV、UV 统计数</span><br>  <span class="hljs-comment"># Display website PV and UV statistics</span><br>  <span class="hljs-attr">statistics:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常</span><br>    <span class="hljs-comment"># Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`</span><br>    <span class="hljs-comment"># Options: busuanzi | leancloud</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;leancloud&quot;</span><br><br>    <span class="hljs-attr">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span><br>    <span class="hljs-attr">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人&quot;</span><br></code></pre></td></tr></table></figure><h2 id="页面效果"><a href="#页面效果" class="headerlink" title="页面效果"></a>页面效果</h2><p><img src="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/%E6%96%87%E7%AB%A0%E6%B5%8F%E8%A7%88%E9%87%8F.png" alt="文章浏览量"></p><p><img src="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/pvuv.png" alt="pv &amp; uv"></p><h1 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h1><p>评论功能相关的代码同样是 Fluid 本身写好的，修改一些配置即可，我们这里使用基于 leancloud 的 valine 来配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>    <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>    <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus | discuss</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br><br><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-string">你的</span> <span class="hljs-string">LeanCloud</span> <span class="hljs-string">AppID</span><br>  <span class="hljs-attr">appKey:</span> <span class="hljs-string">你的</span> <span class="hljs-string">LeanCloud</span> <span class="hljs-string">AppKey</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br>  <span class="hljs-attr">placeholder:</span> <span class="hljs-string">说点什么...</span><br>  <span class="hljs-attr">avatar:</span> <span class="hljs-string">&#x27;retro&#x27;</span><br>  <span class="hljs-attr">meta:</span> [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  <span class="hljs-attr">requiredFields:</span> []<br>  <span class="hljs-attr">pageSize:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">lang:</span> <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  <span class="hljs-attr">highlight:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">recordIP:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">serverURLs:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">emojiCDN:</span><br>  <span class="hljs-attr">emojiMaps:</span><br>  <span class="hljs-attr">enableQQ:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="页面效果-1"><a href="#页面效果-1" class="headerlink" title="页面效果"></a>页面效果</h2><p><img src="/2023/10/07/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E8%87%AA%E8%BF%B0/comments.png" alt="发表评论"></p><h1 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h1><p>这部分插件通常需要用到额外的 js&#x2F;css 文件，需要添加到 <code>source/js</code> 文件夹中</p><blockquote><p>所有这部分文件都可以在<a href="https://github.com/duhaode520/duhaode520.github.io">博客原始 repo </a>的 source 文件夹中找到</p></blockquote><h2 id="添加主页创建时间"><a href="#添加主页创建时间" class="headerlink" title="添加主页创建时间"></a>添加主页创建时间</h2><p>在 <code>_config.fluid.yml</code> 中找到 <code>footer</code> 进行添加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">footer:</span><br>  <span class="hljs-comment"># 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题</span><br>  <span class="hljs-comment"># HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more people</span><br>  <span class="hljs-attr">content:</span> <span class="hljs-string">&#x27;</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;</span><br><span class="hljs-string">      &lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="hljs-string">      &lt;script src=&quot;/js/duration.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>然后创建文件 <code>source/js/duration.js</code>，其中内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createtime</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> grt= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;03/10/2023 00:00:00&quot;</span>);<span class="hljs-comment">//在此处修改你的建站时间，格式：月/日/年 时:分:秒</span><br>    now.<span class="hljs-title function_">setTime</span>(now.<span class="hljs-title function_">getTime</span>()+<span class="hljs-number">250</span>);<br>    days = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> / <span class="hljs-number">24</span>; dnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(days);<br>    hours = (now - grt ) / <span class="hljs-number">1000</span> / <span class="hljs-number">60</span> / <span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * dnum); hnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(hours);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title class_">String</span>(hnum).<span class="hljs-property">length</span> ==<span class="hljs-number">1</span> )&#123;hnum = <span class="hljs-string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="hljs-number">1000</span> /<span class="hljs-number">60</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * hnum);<br>    mnum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(minutes); <span class="hljs-keyword">if</span>(<span class="hljs-title class_">String</span>(mnum).<span class="hljs-property">length</span> ==<span class="hljs-number">1</span> )&#123;mnum = <span class="hljs-string">&quot;0&quot;</span> + mnum;&#125;<br>    seconds = (now - grt ) / <span class="hljs-number">1000</span> - (<span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * dnum) - (<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * hnum) - (<span class="hljs-number">60</span> * mnum);<br>    snum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(seconds); <span class="hljs-keyword">if</span>(<span class="hljs-title class_">String</span>(snum).<span class="hljs-property">length</span> ==<span class="hljs-number">1</span> )&#123;snum = <span class="hljs-string">&quot;0&quot;</span> + snum;&#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;timeDate&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="hljs-string">&quot; 天 &quot;</span>;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;times&quot;</span>).<span class="hljs-property">innerHTML</span> = hnum + <span class="hljs-string">&quot; 小时 &quot;</span> + mnum + <span class="hljs-string">&quot; 分 &quot;</span> + snum + <span class="hljs-string">&quot; 秒&quot;</span>;<br>&#125;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&quot;createtime()&quot;</span>,<span class="hljs-number">250</span>);<br></code></pre></td></tr></table></figure><h2 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a>动态彩带</h2><p>首先在 <code>_config.fluid.yml</code> 中找到 <code>custom.js</code> 进行添加:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/js/DynamicRobbin.js</span><br></code></pre></td></tr></table></figure><p>然后添加文件 <code>source/js/DynamicRobbin.js</code>，在项目repo中直接拷贝即可：<a href="https://github.com/duhaode520/duhaode520.github.io/tree/main/source/js/DynamicRobbin.js">https://github.com/duhaode520/duhaode520.github.io/tree/main/source/js/DynamicRobbin.js</a>  </p>]]></content>
    
    
    <categories>
      
      <category>博客建站</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/10/06/test-article/"/>
    <url>/2023/10/06/test-article/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2023/10/06/test-article/test.png" class="" title="图片引用方法一"><p><img src="/2023/10/06/test-article/test.png" alt="图片引用方法二"></p><p><img src="/images/test.png" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper简介</title>
    <link href="/2023/04/22/Zookeeper%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/04/22/Zookeeper%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>Zookeeper 可以用来构建一般的分布式应用，对部分失败进行正确的处理</p><div class="note note-primary">            <p>💡 什么是部分失败？简单来讲就是消息在网络中传输的一方不知道另一方是不是有问题，比如接受者down掉或者根本没有接受到，发送方是不能知道这条个操作是不是已经失败的</p>          </div><p>Zookeeper 的一些核心理念：</p><ul><li>精简的文件系统</li><li>高可用性：避免出现单点故障，构建可靠应用</li><li>松耦合：让<strong>进程在不了解其他进程（或网络状况）的情况</strong>下能够彼此发现并实现交互，甚至不要求二者是同时存在的</li><li>高性能：10000ops +</li></ul><p>Zookeeper 的一些命令行指令：基本都是4个单词的，通常在 port：2181 进行监视</p><h2 id="Zookeeper-服务"><a href="#Zookeeper-服务" class="headerlink" title="Zookeeper 服务"></a>Zookeeper 服务</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Zookeeper 被设计用来实现协调服务，其数据的访问具有原子性</p><div class="note note-primary">            <p>💡 也就是说与 HDFS 不同，其读取数据时不会出现部分读，要么成功，要么失败，同样的，对于写操作来说，其也会一次性更新 znode 中的所有数据，而不是只在最后进行添加。<br>Zookeeper保证了读写的原子性</p>          </div><p><strong>znode</strong></p><p>znode 分为短暂 znode 和永久 znode。其中永久 znode 需要显式地被删除，而短暂 znode 在<strong>当前客户端的会话</strong>结束时就会消失</p><div class="note note-primary">            <p>💡 关于会话（session）和连接（connect）之间的区别，请看后文的内容</p>          </div><p>短暂 znode 不可以用有子节点，其比较适合实现组成员管理，让进程知道特定的时刻有那些子成员可以被使用。</p><div class="note note-info">            <p>💡 详情见 21.2.3, 21.2.4 中 <code>JoinNode</code> 和 <code>ListNode</code> 的例子，短暂 znode 添加的子成员能够被 <code>ListNode</code> 在他们不知情的情况下发现。</p>          </div><p><strong><strong><strong>Sequence Number</strong></strong></strong></p><p>顺序号可以给全局的同名时间排列顺序，比如两个先后有不同客户端创建的 znode 在 Zookeeper 路径中会被管理为 <code>/a/b-2</code> 和 <code>/a/b-3</code> 。顺序号并不会在路径访问中被显式需要。</p><div class="note note-info">            <p>💡 顺序号涉及到了 Zookeeper 另外一个非常重要的功能，就是实现分布式锁</p>          </div><p><strong>Watch</strong></p><p>每一个 znode 都可以设置多个观察，有不同的对于 znode 的操作可以触发观察。观察在触发后会通知设置该观察的客户端，然后消失。</p><div class="note note-info">            <p>💡 也就是说每一个观察只能触发一次，如果想要多次接受通知，需要不断的设置观察</p>          </div><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><img src="/2023/04/22/Zookeeper%E7%AE%80%E4%BB%8B/operation.png" alt="Operation list"></p><p>在更新（ <code>setData</code> , <code>delete</code> 时需要提供版本号，可以由 <code>exists</code> 方法获取，且这个更新操作是非阻塞的（可能同时由其他的客户端在更新）</p><p>Zookeeper 提供了一个 multi 的操作，可以将多个操作打包为一个原子性的操作，一起成功一起失败</p><p>Zookeeper 提供了同步和异步的API，通常会使用异步的API以流水线的方式来处理请求。</p><p><img src="/2023/04/22/Zookeeper%E7%AE%80%E4%BB%8B/znode_watcher.png" alt="这个表提供了什么操作的可以对 znode 设置观察，以及他们是怎么被出发的"></p><p>这个表提供了什么操作的可以对 znode 设置观察，以及他们是怎么被出发的</p><p>Zookeeper 还提供了权限管理的功能，用户登录需要通过身份验证（IP，或者密码组合等方式）来获取自己的 ACL (Access Control List) </p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有两种模式：standalone（单机）、replicated</p><p>在复制模式先，需要集群中有超过一半的机器可用，所以一般 Zookeeper 集群中总是有单数台机器（比如5台-容忍2台宕机，但是 6台服务器同样只能容忍2台宕机）</p><p>一般有两个阶段</p><ol><li>领导者选举：选出一台保持最新状态的 leader，其他人成为 follower</li><li>原子广播：所有对于 znode 的更改都会现在 leader 中更改并持久化，然后 leader 才回广播这个修改，而且这个达成协议的过程对于每一个节点都是原子性的。</li><li>一旦领导者出现问题，会快速再选选举一个领导者，然后恢复正常的原 leader 会自动不变为 follower</li></ol><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一个 follower 可能落后 leader 数个版本，可以通过 <code>sync()</code> 函数完成一致性更新。</p><p>每个 Client 并不知道自己连接到的是 follower 还是 leader，但是只有他重新连接，他就不会连接到比自己原先更老的服务器版本，这一点有 znode 顺序号进行保证。</p><p>顺序一致性、操作原子性、更新持久性等均可以实现对于 Zookeeper 的一致性保证</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>客户端一旦与一个 Zookeeper 服务器建立连接就产生了一个 Session，客户端可以定期发送 ping 信号来保证 session 不过期</p><div class="note note-primary">            <p>💡 session 连接的 Zookeeper 服务器故障后，Zookeeper 保证了对于服务器的自动切换，所有与故障服务器相关的 session 在切换后仍然是有效的，这个切换过程对于用户是透明的</p>          </div><p>ping 的时间通常会设置为 2~20 个 tick，tick一般为 2s</p><p>通常来说，服务器越多，构建的暂时状态越复杂，越应该设置较长的 ping 时间</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态图如下，一个 Zookeeper 对象只能出于一种状态，同时状态的切换会出发 watcher</p><p><img src="/2023/04/22/Zookeeper%E7%AE%80%E4%BB%8B/states.png" alt="States"></p><h2 id="Zookeeper-构建应用"><a href="#Zookeeper-构建应用" class="headerlink" title="Zookeeper 构建应用"></a>Zookeeper 构建应用</h2><h3 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h3><p>Zookeeper 可以作为一个高可用的配置存储器，允许分布式应用的参与者检索和更新配置文件</p><p>可以利用 znode 以键值对的方式存储配置，并提供多种层级的支持</p><p>利用 Watcher 观察 <code>NodeDataChanged</code> 事件来在不同的客户端中同步配置</p><h3 id="可复原的-Zookeeper-应用"><a href="#可复原的-Zookeeper-应用" class="headerlink" title="可复原的 Zookeeper 应用"></a>可复原的 Zookeeper 应用</h3><p>捕捉 <code>KeeperException</code> ，并根据其类别来对应用进行恢复</p><p>要注意幂等和非幂等操作的区别，幂等操作可以多次重复，而非幂等操作啧不能盲目的重试</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>提供一组进程间的互斥机制，可以用于在大型分布式系统中实现领导者选举，持有锁的进程就是领导者</p><p>思路很简单，创建一个锁的 znode，然后在他的下面创建一些子 znode，如 <code>/leader/lock-1</code>, <code>/leader/lock-2,</code> 任何时候顺序小的持有锁</p><p>申请获取锁的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> Create an ephemeral sequential znode named lock- under the lock znode, and<br>remember its actual <span class="hljs-title function_">pathname</span> <span class="hljs-params">(the return value of the create operation)</span>.<br><span class="hljs-number">2.</span> Get the children of the lock znode and set a watch.<br><span class="hljs-number">3.</span> If the pathname of the znode created in step <span class="hljs-number">1</span> has the lowest number of the children<br>returned in step <span class="hljs-number">2</span>, then the lock has been acquired. Exit.<br><span class="hljs-number">4.</span> Wait <span class="hljs-keyword">for</span> the notification from the watch set in step <span class="hljs-number">2</span>, and go to step <span class="hljs-number">2.</span><br></code></pre></td></tr></table></figure><p>两个潜在的问题：</p><p><strong><strong>羊群效应</strong></strong></p><ul><li>解释：每个 client 都会在锁 znode 上放置一个观察，每次状态变化时会可能会有大量的客户端受到同一事件的通知，但是只有很少一部分需要处理这个事件，这样会造成网络带宽的峰值压力过大</li><li>解决：只在当前子节点消失时，通知其下一个子节点</li></ul><p><strong><strong>可恢复异常</strong></strong></p><ul><li>描述：在创建锁 znode 时，我们不能处理由于连接丢失导致的创建失败（partial failure)。我们不能简单的进行重试，否则会出现孤儿 znode</li><li>解决：在znode中加入 sessionID，构成 <code>lock-&lt;sessionID&gt;-&lt;sequenceNumber&gt;</code> 的名称序列，在重新连接时进行搜索。</li></ul><h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>还会存在除了 leader 和 follower 之外的角色：observer，是没有投票权的跟随者，可以将 observer 放置在不同于 leader 和 follower 的机架中，这样既不影响性能，也能够提高整个 Zookeeper 服务的可用性</p><p>主要使用 3 个端口：</p><ul><li>2181：客户端连接</li><li>2888：对于 leader 来说，follower 从这个端口进行连接</li><li>3888：领导者选举阶段的其他服务器连接</li></ul><p>应用：</p><ul><li>为 HDFS 的 Namenode 提供高可用性支持</li><li>为 Yarn 的 resourcemanager 提供高可用支持</li></ul><p>主要是快速的主备切换</p>]]></content>
    
    
    
    <tags>
      
      <tag>引擎基础</tag>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDFS I/O</title>
    <link href="/2023/04/01/HDFS-I-O/"/>
    <url>/2023/04/01/HDFS-I-O/</url>
    
    <content type="html"><![CDATA[<h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>HDFS 通过校验和的计算来保证完整性，一般认为计算4个字节的校验和带来的额外的存储（1%）和计算开销都是可接受的</p><p>HDFS 在以下几个层面保障数据完整性：</p><ul><li>datanode 在收到数据后验证 checksum，在整个写过程的 pipeline 的最后一个 datanode 负责校验和，返回 IOException</li><li>读取时也会校验 checksum，datanode 会维护一个 checksum 的检测日志，每一次读取检查后更新检测日志</li><li>datanode 的后台线程也会定期检查存储在 datanode 中的所有块的 checksum</li></ul><p>处理损坏块的方法是直接覆盖或者把当前这个datanode中的块放弃掉，尝试将数据复制到新的datanode</p><p>在本地系统可以使用 <code>LocalFileSystem</code> 实现数据完整性的检验，同时可以用 <code>ChecksumFileSystem</code> 进行其他文件系统的封装</p><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>集中常见压缩的优缺点：</p><ul><li>gzip：DEFLATE算法，无法切分，压缩解压缩速度比较快，适合中途小文件的传输（map过程中）</li><li>bzip2：可以切分，用于创建map任务，但是压缩解压速度慢</li><li>lzo：在构建索引的情况下可切分</li><li>snappy：不可切分，也是快速压缩算法</li></ul><p>Hadoop 对于集中常用的压缩算法都有对应的 Codec 类进行实现</p><h3 id="压缩的编程实现"><a href="#压缩的编程实现" class="headerlink" title="压缩的编程实现"></a><strong>压缩的编程实现</strong></h3><p>使用 codec 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; codecClass = Class.forName(codecClassname);<br><span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br><span class="hljs-type">CompressionCodec</span> <span class="hljs-variable">codec</span> <span class="hljs-operator">=</span> (CompressionCodec)<br>ReflectionUtils.newInstance(codecClass, conf);<br><span class="hljs-comment">// 下面这个实际上就是对 OutputStream 进行封装，显然换成 FSDataOutputStream 也可</span><br><span class="hljs-type">CompressionOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> codec.createOutputStream(System.out);<br>codec.createOutputStream(OutStream out);<br></code></pre></td></tr></table></figure><p>上文的通过反射的实例构建也可以通过一个工厂类来实现 <code>CompressionCodecFactory.getCodec()</code> ，通过文件的后缀名来推断压缩类型</p><div class="note note-primary">            <p>💡 在压缩解压的过程中直接调用原生（native）代码库可以显著提升速度</p>          </div><p>在需要执行大量压缩解压缩的过程时也可以使用 <code>CodecPool</code></p><h3 id="MapReduce-中的压缩"><a href="#MapReduce-中的压缩" class="headerlink" title="MapReduce 中的压缩"></a>MapReduce 中的压缩</h3><div class="note note-primary">            <p>💡 压缩格式的选择：尽量选择可切分的压缩格式，或者在压缩前进行切分，然后分别压缩，保证切分的结果近似地等于HDFS块的大小</p>          </div><p>通过以下方法在 job 的 output 中直接集成压缩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputFormat.setCompressOutput(job, <span class="hljs-literal">true</span>);<br>FileOutputFormat.setOutputCompressorClass(job, GzipCodec.class);<br></code></pre></td></tr></table></figure><p>同时可以通过 config 来设置是否在 map 的中间结果中使用压缩，以获取进一步的性能提升</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化用于分布式数据处理的两大另一：进程间通信和永久存储</p><p>序列化需要的特点：紧凑（节省带宽），快速（复用次数高）、可拓展（总会有新的需求）、支持互操作（不同端的交互）</p><h3 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h3><p>Hadoop的序列化通过 Writable 接口实现，然后 Writable 接口有衍生出来分别对应了不同的 java 数据类型的 Writable 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Writable</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(DataOutput out)</span> <span class="hljs-keyword">throws</span> IOException;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">readFields</span><span class="hljs-params">(DataInput in)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>DataOutput</code> 和 <code>DataInput</code> 是 <a href="http://java.io/">java.io</a> 中的两个接口，其实现分别是 <code>DataOutputStream</code> 和 <code>DataInputStream</code> </p><p><code>WritableComparable</code> 由其名字可以看出，分别实现了<code>Writable</code> 和 <code>Comparable</code> 这两个接口，对应的 <code>WritableComparator</code> 则稍有不同，这个类在具体实现的同时，还充当了一个工厂类的角色，生成不同类型的 <code>RawComparator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RawComparator&lt;IntWritable&gt; comparator = WritableComparator.get(IntWritable.class);<br></code></pre></td></tr></table></figure><ul><li><p>下面可以去看一下 <code>WritableComparator</code> 这个类的源码，因为后面对于 <code>TextPair</code> 的 <code>comparator</code> 的构建要用到这个类</p></li><li><p>下面是一个Hadoop Writable 的继承关系图：值得注意的是 int 和 long 对应的 Writable 有变长版本，一般会使用变长版本的，这样比较节省空间</p><p>  <img src="/2023/04/01/HDFS-I-O/Writable.png" alt="Writable 类图"></p></li></ul><p><code>Text</code> 类型相当于 <code>String</code> 但是在索引上又有所不同，Text 的长度是按照 Byte 进行计算的，索引(<code>charAt()</code>)也大多会索引到 byte。<code>Text</code> 的这种特性也使得其遍历相当麻烦，需要用如下一个利用 <code>ByteBuffer</code> 进行转换的方法遍历每一个字符，当然直接调用 <code>toString()</code> 方法可能是更方便的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextIterator</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Text</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;\u0041\u00DF\u6771\uD801\uDC00&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(t.getBytes(), <span class="hljs-number">0</span>, t.getLength());<br><span class="hljs-type">int</span> cp;<br><span class="hljs-keyword">while</span> (buf.hasRemaining() &amp;&amp; (cp = Text.bytesToCodePoint(buf)) != -<span class="hljs-number">1</span>) &#123;<br>System.out.println(Integer.toHexString(cp));<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>❓ 那什么时候只能对 <code>Text</code> 进行操作呢，一行特别长吗？但是这样的情况在读取的时候不会有处理吗，比如一个块其实也就128M，这128M也不会一次直接全读成 <code>Text</code></p>          </div><p><code>NullWritable</code> 在 MapReduce 过程中不需要某一个 value 时可以声明，可以高效存储空值，节省带宽</p><div class="note note-primary">            <p>❓ 一个不太重要的小问题：ObjectWritable 和 GenericWritable 的区别？ 书上给出的事 GenericWritable 使用静态类型的数组并加入索引以提高性能。</p>          </div><h3 id="Writable-的定制化"><a href="#Writable-的定制化" class="headerlink" title="Writable 的定制化"></a>Writable 的定制化</h3><p>如果我们希望针对一个 Hadoop 没有实现的数据结构实现在 Hadoop 上的序列化，我们最好的方法是新建一个新的 Writable 类型</p><p>在新建 Writable 类型后，我们往往为了避免在比较过程中需要将对象进行反序列化，需要重新写一个 RawComparator 想办法在字节层面上对对象进行比较</p><p>Serialization 是一个比 Writable 更大的范畴，Hadoop 也提供了一个除了包含 Writable 的更 general 的 framework，除此之外还可以使用别的，比如 Avro</p><h2 id="SequenceFile"><a href="#SequenceFile" class="headerlink" title="SequenceFile"></a>SequenceFile</h2><p>SequenceFile 设计出来有两个功能：</p><ul><li>一方面可以提供一个二进制的键值对存储结构</li><li>另外一方面可以作为小文件的容器对小文件进行包装(why?)</li></ul><div class="note note-primary">            <p>💡 通常解决”小文件问题”的回应是：使用 SequenceFile。这种方法的思路是，使用文件名作为 key， 文件内容作为 value<br>在实践中这种方式非常有效。我们回到10,000个100KB大小的小文件问题上，你可以编写一个程序 将合并为一个 SequenceFile，然后你可以以流式方式处理(直接处理或使用 MapReduce) SequenceFile。这样会带来两个优势：<br>SequenceFiles 是可拆分的，因此 MapReduce 可以将它们分成块，分别对每个块进行操作；<br>与 HAR 不同，它们支持压缩。在大多数情况下，块压缩是最好的选择，因为它直接对几个记录组 成的块进行压缩，而不是对每一个记录进行压缩。<br>将现有数据转换为 SequenceFile 可能会很慢。但是，完全可以并行创建一个一个的 SequenceFile 文件。 Stuart Sierra 写了一篇关于将 tar 文件转换为 SequenceFile 的文章，像这样的工具是非常 有用的，我们应该多看看。向前看，最好设计好数据管道，如果可能的话，将源数据直接写入 SequenceFile ，而不是作为中间步骤写入小文件。<br>与 HAR 文件不同，没有办法列出 SequenceFile 中的所有键，所以不能读取整个文件。 Map File， 类似于对键进行排序的 SequenceFile，维护部分索引，所以他们也不能列出所有的键<br>原文链接：<a href="https://blog.csdn.net/qq_43061290/article/details/124822293">https://blog.csdn.net/qq_43061290&#x2F;article&#x2F;details&#x2F;124822293</a></p>          </div><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p><strong>读</strong></p><p>reader可以直接实例化，然后通过 <code>next()</code> 和 <code>getCurrentValue()</code> 来读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SequenceFile</span>.Reader(fs, path, conf);<br><span class="hljs-type">Writable</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (Writable)<br>ReflectionUtils.newInstance(reader.getKeyClass(), conf);<br><span class="hljs-type">Writable</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Writable)<br>ReflectionUtils.newInstance(reader.getValueClass(), conf);<br><span class="hljs-type">long</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> reader.getPosition();<br><span class="hljs-keyword">while</span> (reader.next(key, value)) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">syncSeen</span> <span class="hljs-operator">=</span> reader.syncSeen() ? <span class="hljs-string">&quot;*&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;<br>System.out.printf(<span class="hljs-string">&quot;[%s%s]\t%s\t%s\n&quot;</span>, position, syncSeen, key, value);<br>position = reader.getPosition(); <span class="hljs-comment">// beginning of next record</span><br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>IOUtils.closeStream(reader);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>❓ 这里有一个问题，我们可以发现代码中提供的读取方式和书中提供的API 是有一些差别的</p>          </div><p>还可以通过 <code>seek(int pos)</code> 函数在顺序文件中进行搜索，但是这个 pos 如果不是边界值的话会报错</p><p>也可以用 <code>sync(int pos)</code> 方法来寻找下一个同步点，这个同步点是由 Writer 在写的过程中创建的</p><div class="note note-primary">            <p>💡 同步点提供在读取过程中因为搜索导致文件指针 lost 后可以快速同步</p>          </div><p> <strong>写</strong></p><p>通过一个可以操作多种数据类型的 <code>createWriter()</code> 创建一个 writer，然后用 <code>append()</code> 函数向其中添加 key 和 value 即可，同时 writer 也是一个 <code>Closable</code> 流，需要 close</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>writer = SequenceFile.createWriter(fs, conf, path,<br>key.getClass(), value.getClass());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>key.set(<span class="hljs-number">100</span> - i);<br>value.set(DATA[i % DATA.length]);<br>System.out.printf(<span class="hljs-string">&quot;[%s]\t%s\t%s\n&quot;</span>, writer.getLength(), key, value);<br>writer.append(key, value);<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>IOUtils.closeStream(writer);<br>&#125;<br></code></pre></td></tr></table></figure><p>writer 中 key value 的类不一定是 <code>Writable</code> ，但是至少应该可以被序列化</p><div class="note note-primary">            <p>💡 SequenceFile 可以很方便用 mapreduce 进行排序合并，或许为管理小文件提供了一些帮助？</p>          </div><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Record Compression （Default）</p><p><img src="/2023/04/01/HDFS-I-O/record_compression.png" alt="Record Compression"></p><p>Block Compression</p><p><img src="/2023/04/01/HDFS-I-O/block_compression.png" alt="Block Compression"></p><div class="note note-primary">            <p>❓ 另外一个不太重要的问题，怎么从压缩的里面读取一条记录</p>          </div><p>块压缩是用记录中的相似性进行压缩的</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>引擎基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Yarn 简介</title>
    <link href="/2023/03/17/YARN-%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/03/17/YARN-%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Yarn的运行机制"><a href="#Yarn的运行机制" class="headerlink" title="Yarn的运行机制"></a>Yarn的运行机制</h2><p><img src="/2023/03/17/YARN-%E7%AE%80%E4%BB%8B/yarn_arch.png" alt="Yarn 的运行机制"></p><p>Yarn中三类重要实体</p><ul><li>resource manager：管理集群上资源使用</li><li>node manager：运行在所有节点上，能够启动和监控容器</li><li>Container：用于执行特定的应用程序，有一定的资源限制</li></ul><p>运行流程：</p><ul><li>客户端联系 resource manager，要求启动一个 application master 进程</li><li>resource manager 找到一个可以启动 application master 的 node manager，然后启动这个容器<ul><li>application运行起来后可能是返回一个计算 application 给客户端，也可能是执行分布式计算——申请资源、创建新的 application 和容器</li></ul></li></ul><p>Yarn 本身不提供通信机制，只是资源的申请分配</p><p>申请分配为了节省带宽还是采用了在网络拓扑上的就近（节点——机架——any）</p><p>按照用户和application之间来分类</p><ul><li>一个用户作业对应一个application：MapReduce</li><li>用户作业中的一个工作流对应一个application：Spark</li><li>多个也用户对一个 application： Slider</li></ul><div class="note note-primary">            <p>🔴 其实就是：一对一，一对多，多对一</p>          </div><h2 id="Yarn的优势"><a href="#Yarn的优势" class="headerlink" title="Yarn的优势"></a>Yarn的优势</h2><ul><li>Scalability：Yarn中对于jobtracker 的资源调度和任务监控的职责分离带来的好处</li><li>Availability：同样是职责分离，resource manager 和 application master 可以分别做高可用</li><li>Utilization: Yarn 对于资源的管理更精细，slot比较大</li><li>Multitenancy：Yarn 可以为更多的应用提供服务，MapReduce仅是期中的一个</li></ul><h2 id="Yarn的调度"><a href="#Yarn的调度" class="headerlink" title="Yarn的调度"></a>Yarn的调度</h2><p>三种调度器：</p><ul><li><p>FIFO调度器：简单不用配置，不适合共享集群，每个任务必须都能到轮到自己才行</p>  <div class="note note-primary">            <p>感觉基本上只适合自己玩玩的时候用，或者资源特别丰盛的时候，每个人实际上own了一个集群可以自己玩     </p>          </div>   </li><li><p><strong>容量调度器：</strong>有一个独立的队列保证小作业的提交和启动，大作业等待的时间相对长 (default)</p></li><li><p>公平调度器：每一个用户平分所有资源（在原有任务释放出来后），每一个用户的任务再分别平分这个用户拥有的所有的资源</p></li></ul><p><strong>容量调度器的配置 <code>capacity-scheduler.xml</code>：</strong></p><p>可以配置每一个队列拥有的固定的 capacity（%） 和用于弹性使用的 max capacity（不设置默认可以占用全部的容量）, 队列还可以通过 <code>a.b.queues</code> 的方式定义子队列</p><p>通过属性 <code>mapreduce.job.queuename</code> 决定任务推送的队列</p><p><strong>公平调度器的配置 <code>fair-scheduler.xml</code>：</strong></p><ul><li><p>权重元素：可以设置哪一个队列的占比更大，通过 <code>queue.weight</code> 属性</p></li><li><p>调度策略：默认是 fair，也可以有队列级的 fifo（只对该队列中的各个任务），DRF (Dominant Resource Fairness, 根据占用最多的资源进行 fair 调度)</p></li><li><p>可以通过 <code>queuePlacementPolicy</code> 设置队列放置规则，默认会有 “specified”, “user”, “primaryGroup”, “default” 等</p>  <div class="note note-primary">            <p>💡 如果只使用 default 则相当于便捷的实现了对于所有任务的公平调度，因为所有任务都会被塞进一个队列中</p>          </div></li><li><p>抢占：公平调度器允许抢占，但是抢占会降低集群的效率</p></li></ul><p><strong><strong>延迟调度</strong></strong></p><p>一个非常tricky的调度策略：如果请求节点容器时发现没有，可以等待数秒（数个heartbeat（一般是1s）），这样可以显著提高在当前节点获得一个容器的机会，而不是下一级节点（节点→机架→others）</p><p>每一个 heartbeat 是一个潜在的调度机会</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>引擎基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop HDFS</title>
    <link href="/2023/03/07/Hadoop-HDFS/"/>
    <url>/2023/03/07/Hadoop-HDFS/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>《Hadoop 权威指南》读书笔记</p>          </div><p>HDFS是流式访问的：一次写入，多次读取且只支持单个写入者，而且是增量写入的</p><h2 id="HDFS的几个基本概念"><a href="#HDFS的几个基本概念" class="headerlink" title="HDFS的几个基本概念"></a>HDFS的几个基本概念</h2><ul><li>数据块：默认为128MB</li></ul><div class="note note-primary">            <p>💡 这个128MB与磁盘的传输速率是匹配的，如果传输速率提高，那么就可以有更大的 block 大小</p>          </div><ul><li>namenode 和 datanode<ul><li>namenode：维护文件系统命名空间（树）：永久保存在本地磁盘</li><li>datanode：储存并检索 blocks，定期向 namenode 报告储存的 block 列表</li><li>两种容错方法：备份文件或者添加辅助namenode</li></ul></li><li>块缓存：一般一个块仅在一个datanode中有块缓存</li><li>联邦HDFS：在数据规模太大时，内存会成为瓶颈——允许多个namenode</li><li>高可用性</li></ul><div class="note note-primary">            <p>💡 区分高可用性和备份：高可用性需要在原有的down之后在不可被用户感知的时间内有新的主机上线</p><p><strong>Hadoop2 维护高可用的方式</strong><br>有一对namenodes处于主备配置。如果活动namenode故障，备用namenode将接管其职责，以继续为客户端请求提供服务而不会出现重大中断。需要进行一些体系结构更改才能实现这一点：</p><ol><li>namenodes必须使用高可用共享存储来共享编辑日志。当备用namenode启动时，它将读取共享编辑日志的末尾以将其状态与活动namenode同步，然后继续读取由活动namenode编写的新条目。</li><li>由于块映射存储在namenode的内存中而不是磁盘上，因此datanodes必须向两个namenodes发送块报告。</li><li>客户端必须配置以处理namenode故障转移，使用对用户透明的机制。</li><li>备用namenode的角色被主备namenodes代替，后者对活动namenode的名称空间进行定期检查点。</li></ol><p>Hadoop 的高可用同时也是使用了 Zookeeper 的，在默认的情况下是用 Zookeeper+心跳监视来实现故障转移</p>          </div><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>HTTP比原生的要慢，不要用他传输大文件（就是用 <code>hdfs://</code> 这种访问来传输文件）</p><h3 id="基于-Java-的读写"><a href="#基于-Java-的读写" class="headerlink" title="基于 Java 的读写"></a>基于 Java 的读写</h3><p><strong>读：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(URI.create(uri), conf);<br><span class="hljs-type">FSDataInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>in = fs.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(uri));<br>in.seek(<span class="hljs-number">0</span>)<br><span class="hljs-comment">// FSDataInputStream extends InputStream</span><br><span class="hljs-comment">// Special Methods:</span><br><span class="hljs-comment">// void seek(long pos);</span><br><span class="hljs-comment">// long getPos();</span><br><span class="hljs-comment">// 实现随机访问和当前位置距离初始的偏移量</span><br></code></pre></td></tr></table></figure><p><strong><strong>写：</strong></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> fs.create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(dst), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Progressable</span>() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">progress</span><span class="hljs-params">()</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;.&quot;</span>);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以重载 <code>Progressable</code> 接口实现写入过程的 progress bar，也可以使用 <code>append(Path f)</code> 函数向一个文件的最后来追加</p><div class="note note-warning">            <p>💡 <code>create</code> 函数可以创建不存在的父文件夹，尽管这样做可能有时并不安全，是递归创建的<br><code>append</code> 由于调用了 <code>create</code>，因此也拥有这样的特性</p>          </div><p>此外，用 <code>FileSystem</code> 的 <code>mkdir</code> 可以创建目录，尽管通常情况不需要这样做</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><code>FileStatus</code> 类保存了文件的 metadata，同时 FS 可以通过 listStatus 函数来列出目录中的所有内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// code example here to covert FileStatus to Path</span><br>FileStatus[] status = fs.listStatus(paths);<br>Path[] listedPaths = FileUtil.stat2Paths(status);<br></code></pre></td></tr></table></figure><p><code>globStatus</code> 方法用于匹配通配符，复杂的基于正则表达式的匹配需要实现 <code>PathFilter</code> 接口</p><p><code>delete</code> 来删除数据，并可以决定是否递归删除</p><h2 id="读写流程解析"><a href="#读写流程解析" class="headerlink" title="读写流程解析"></a>读写流程解析</h2><h3 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h3><p><img src="/2023/03/07/Hadoop-HDFS/read.jpeg" alt="HDFS read"></p><ul><li><code>open</code> 打开一个要读取的文件，创建 InputStream<ul><li>这个过程通过 FileSystem 向 Namenode 发送一个RPC实现，申请文件起始块的地址</li><li>对于每一个块请求，Namenode 会返回一个 block 所在的 Datanode 的地址</li><li>这些地址是按照网络拓扑的远近顺序返回的</li></ul></li><li><code>read</code> 函数让 InputStream 去进行读操作，InputStream 会找到最近的 Datanode 读取第一个块</li><li>在这个块读取完时，InputStream关闭和这个 Datanode 的连接，并转到下一个最近的 Datanode 继续读取<ul><li>FS 向 Namenode 请求文件块的地址是一批一批的，在这一批读完前会请求到下一批的地址，读取过程是连续的</li><li>Namenode 储存文件快的起始地址是在内存中的，所以非常高效</li></ul></li><li>读取完成后关闭连接</li></ul><div class="note note-primary">            <p>🔴 容错和故障处理：如果发现连接失败或者读取的块不完整，FS 会通知 namenode，以后不从这个 datanode 中进行读取。</p>          </div><h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><p><img src="/2023/03/07/Hadoop-HDFS/write.jpeg" alt="HDFS write"></p><ul><li>首先用 <code>create</code> 方法来创建文件，然后同样由 FS 向 Namenode 发送一个 RPC 来进行 namenode 处文件记录的创建</li><li>Namenode 会进行也系列检查确保创建是合法且有权限的，然后返回给 FS，这个时候 FS 会返回给 client 一个 OutputStream。OutputStream 负责进行 Namenode 和 datanode 的通信。</li><li>OutputStream 将要写入的 blocks 放入一个 data queue，然后执行一个流水线过程<ul><li>OutStream 将 block 写入请求到的最近的 datanode</li><li>然后datanode将其流水线写到 replica 的 datanode中</li><li>然后再流水线返回</li><li>OutputStream 还维护一个 ack queue，记录完全写完的block</li></ul></li></ul><div class="note note-primary">            <p>🔴 故障容错处理：如果有一个写入故障的数据包，立刻关掉整个pipeline，把所有在pipeline 中的数据包返回到数据队列的前端，然后在正常的 datanode 的 block 制定一个表示，然后传递给 namenode。 namenode 意识到 repica 不足时，会继续在新节点上创建副本</p>          </div><ul><li>整个在写入完成后调用 close 方法</li></ul><h2 id="distcp复制"><a href="#distcp复制" class="headerlink" title="distcp复制"></a>distcp复制</h2><p>distcp 可以提供 HDFS 之间的大批量复制</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hadoop</tag>
      
      <tag>引擎基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
